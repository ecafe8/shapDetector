<!DOCTYPE html>
<html>
<head>
	<title>shape detector</title>
	<style>
		.file-container {
			margin: 10px 0;
		}
		canvas {
			border: 1px solid red;
		}
		#detector-container {
			position: relative;
			margin-top: 20px;
		}
		.imgCanvas,
		.signCanvas {
			position: absolute;
			top: 0;
			left: 0;
		}
		.loading {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			display: none;
			width: 500px;
			height: 500px;
			text-align: center;
			background: rgba(255, 255, 255, .5);
		}
		.loading span {
			display: inline-block;
			width: 20px;
			height: 20px;
			margin: 150px 10px 0;
			border-radius: 100%;
			background: #e8e6e6;
		}
		.loading span:nth-child(1) {
			animation: loading .5s ease-out infinite alternate backwards;
		}
		.loading span:nth-child(2) {
			animation: loading .5s .2s ease-out infinite alternate backwards;
		}
		.loading span:nth-child(3) {
			animation: loading .5s .4s ease-out infinite alternate backwards;
		}
		@keyframes loading {
			from {
				transform: translateY(0);
			}
			to {
				transform: translateY(-35px);
			}
		}
	</style>
</head>
<body>
	<div class='file-container'>
		<input type='file' multiple id='file'/>
		<button id='detector'>面部检测</button>
	</div>
	<div id='tag-container'>
		<p>请在图中点击需标记的方框</p>
		<input type='text' id='tag' />
	</div>
	<div id='detector-container'>
	</div>
	<script>
		window.onload = function() {
			let files = document.getElementById('file');
			let reader = new FileReader();
			let faceTag = new FaceTag({
				containerId: 'detector-container',
				canvasWidth: 500,
				canvasHeight: 500
			});
			let tag = document.getElementById('tag');
			let btnDetector = document.getElementById('detector');
			let face = null;
			let loading = document.getElementById('loading');
			let image = new Image();

			reader.onload = () => {
				image.onload = function() {
					faceTag.hideLoading();
					faceTag && faceTag.img.drawZoomImage({
						img: image,
						w: image.width,
						h: image.height
					});
				}
				image.src = reader.result;
			}

			files.addEventListener('change', () => {
				if(files.files.length === 0) {
					return;
				}

				reader.readAsDataURL(files.files[0]);
				faceTag.showLoading();
			})

			tag.addEventListener('blur', () => {
				if(!tag.value || !photoTag || !face) {
					return;
				}
				faceTag.drawZoomImage();
				faceTag.faces.forEach(face => {
					faceTag.drawRect(face.boundingBox);
				})

				faceTag.signTool.drawText(tag.value, face.boundingBox.x, face.boundingBox.y - 50);
			})

			btnDetector.addEventListener('click', () => {
				faceTag.showLoading();
				faceTag && faceTag.faceDetector()
								.then(faces => {
									faceTag.hideLoading();
								})
								.catch(err => alert(err))
			})
		}

		function isHTMLElement(dom) {
			return dom && dom instanceof HTMLElement && dom.nodeType === 1;
		}

		class FaceTag {
			constructor(opt={}) {
				if(opt.containerId && typeof opt.containerId === 'string') {
					this.container = document.getElementById(opt.containerId);
				}else if(isHTMLElement(opt.container)) {
					this.container = opt.containerId;
				}else {
					this.container = document.createElement('div');
					document.body.appendChild(this.container);
				}

				let orignOpt = {
					loading: true
				}
				Object.assign(orignOpt, opt)

				let imgOpt = this.createOpt('imgCanvas', orignOpt);
				this.img = new ShowImg(imgOpt);

				let signToolOpt = this.createOpt('signCanvas', orignOpt);
				this.signTool = new SignTool(signToolOpt);

				this.detector = new FaceDetector(orignOpt.detectorOpt);

				if(orignOpt.loading) {
					this.appendLoading();
				}
				
			}

			createOpt(className, opt) {
				let canvas = this.createCanvas();
				let ctx = this.getContext(canvas);

				canvas.className = className;

				this.resizeCanvas(canvas, {
					w: opt.canvasWidth, 
					h: opt.canvasHeight
				});
				this.mountCanvas(this.container, canvas);
				return {canvas, ctx}
			}

			createCanvas() {
				return document.createElement('canvas');
			}

			mountCanvas(container, child) {
				container.appendChild(child);
			}

			resizeCanvas(canvas, size={w:0, h:0}) {
				if(!this.isCanvas(canvas)) {
					return false;
				}

				canvas.width = parseFloat(size.w),
				canvas.height = parseFloat(size.h);

				return true;
			}

			getContext(canvas) {
				return this.isCanvas(canvas) && canvas.getContext('2d');
			}

			isCanvas(dom) {
				return dom && dom.tagName.toLowerCase() === 'canvas';
			}

			getImage() {
				return this.img.getImage();
			}

			drawRect(box, aspect) {
				this.signTool.drawRect(box, aspect);
			}

			getImageEle() {
				return new Promise((resolve, reject) => {
					let img = new Image();
					img.onload = () => {
						resolve(img);
					};
					img.error = err => {
						reject(err);
					}
					img.src = this.getImage();
				})
			}

			faceDetector(aspect = 1) {
				return new Promise((resolve, reject) => {
					this.getImageEle()
						.then(img => {
							this.detector.detect(img)
								.then(faces => {
									if(faces.length === 0) {
										reject('检测不到面部哦');
									}else {
										this.faces = faces;
										this.drawFace(aspect);
										resolve(this.faces);
									}
									this.signTool.faces = faces;
								})
								.catch(err => {
									reject(err);
								})
						})
				})
			}

			drawFace(aspect = 1) {
				this.signTool.drawFace(aspect);
			}

			appendLoading() {
				let fragment = document.createDocumentFragment(),
					div = document.createElement('div'),
					span1 = document.createElement('span'),
					span2 = document.createElement('span'),
					span3 = document.createElement('span');

				div.appendChild(span1);
				div.appendChild(span2);
				div.appendChild(span3);
				fragment.appendChild(div);

				div.className = 'loading';

				this.loading = div;

				this.container && this.container.append(fragment);
			}

			showLoading() {
				this.loading.style.display = 'block';
			}

			hideLoading() {
				this.loading.style.display = 'none';
			}
		}

		class ShowImg {
			constructor(opt={}) {
				if(typeof opt !== 'object' || !opt.canvas || !opt.ctx) {
					alert('Missing canvas or ctx');
					return;
				}

				this.canvas = opt.canvas;
				this.ctx = opt.ctx;
				this.aspect = 1;
			}

			drawOriginImage(img, s=0, e=0) {
				img = img || this.image;
				if(!img) {
					return;
				}
				this.ctx.drawImage(img, s, e);
				this.image = img;
				return this;
			}

			drawZoomImage(image={
				img: this.image,
				w: 0,
				h: 0
			}) {
				let scale = 1;
				let canvas = this.canvas;
				this.clearRect(0, 0, canvas.width, canvas.height);

				if(image.w / canvas.width >= image.h / canvas.height) {
					scale = image.h / image.w;
					let scaleH = canvas.width * scale;
					this.aspect = scaleH / image.height;
					this.ctx.drawImage(image.img, 0, 0, image.w, image.h, 0, 0, canvas.width, scaleH);
				}else {
					scale = image.w / image.h;
					let scaleW = canvas.height * scale;
					this.aspect = scaleW / image.w;
					this.ctx.drawImage(image.img, 0, 0, image.w, image.h, 0, 0, scaleW, canvas.height);
				}
				// 保存缩放后的照片
				this.image = new Image();
				this.image.src = this.canvas.toDataURL();
			}

			getImage() {
				return this.canvas.toDataURL();
			}

			clearRect(x, y, w, h) {
				this.ctx.clearRect(x, y, w, h);
			}
		}

		class SignTool {
			constructor(opt={}) {
				if(typeof opt !== 'object' || !opt.canvas || !opt.ctx) {
					alert('Missing canvas or ctx');
					return;
				}

				this.canvas = opt.canvas;
				this.ctx = opt.ctx;
				this.canvasBox = this.canvas.getBoundingClientRect();

				this.addEvent();
			}

			drawFace(aspect = 1) {
				this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
				this.faces && this.faces.length > 0 && this.faces.forEach(face => {
					this.drawRect(face.boundingBox, aspect);
				})
			}

			drawRect(rect={}, aspect = 1) {
				this.ctx.save()
				this.ctx.lineWidth = rect.lineWidth || 2;
				this.ctx.strokeStyle = rect.color || 'red';
				this.ctx.rect(Math.floor(rect.x * aspect),
								Math.floor(rect.y * aspect),
								Math.floor(rect.width * aspect),
								Math.floor(rect.height * aspect)
							);
				this.ctx.stroke();
				this.ctx.restore();
			}

			/*
			 * 查找(x,y)是否在某个面部区域内
			 */
			findFace(x, y) {
				return new Promise((resolve, reject) => {
					if(!this.faces || this.faces.length <= 0 || x < 0 || y < 0) {
						reject('none');
					}

					if(!this.image && (x > this.image.width || y > this.image.height)) {
						reject('none');
					}

					let indexFace = null;
					this.faces.forEach(face => {
						let box = face.boundingBox;
						if(x >= box.left && x <= box.right && y >= box.top && y <= box.bottom) {
							indexFace =  face;
						}
					})

					if(indexFace === null) {
						reject('none');
					}else {
						resolve(indexFace);
					}
				})
			}

			addEvent() {
				if(!this.canvas) {
					return;
				}

				this.canvas.addEventListener('click', e => {
					// 计算鼠标在canvas中的位置
					let eX = e.clientX - this.canvasBox.left;
					let eY = e.clientY - this.canvasBox.top;
					this.heightLighRect(eX, eY)
						.catch(err => {
							alert(err)
						})
				})
			}

			heightLighRect(x, y) {
				alert(this.findFace)
					this.findFace(x, y)
						.then(face => {
							alert(face)
							console.log(face)
							let box = face.boundingBox;
							this.clearRect(box.x, box.y, box.width, box.height);
							this.drawRect({
								x: box.x,
								y: box.y,
								width: box.width,
								height: box.height,
								color: 'green'
							})
							this.chooseFace = face;
						})
					tag.value = '';
			}

			drawText(text, x, y, color='white') {
				this.ctx.save();
				this.ctx.fillStyle = color;
				this.ctx.font = '48px serif';
				this.ctx.textBaseline = 'top';
				this.ctx.fillText(text, x, y)
				this.ctx.restore();
			}

			clearRect(s, e, w, h) {
				this.ctx && this.ctx.clearRect(s, e, w, h);
			}
		}
	</script>
</body>
</html>