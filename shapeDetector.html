<!DOCTYPE html>
<html>
<head>
	<title>shape detector</title>
	<style>
		body {
			padding: 0;
			margin: 0;
		}
		.file-container {
			margin: 10px 0;
		}
		canvas {
			border: 1px solid red;
		}
	</style>
</head>
<body>
	<div class='file-container'>
		<input type='file' multiple id='file'/>
		<button id='detector'>面部检测</button>
	</div>
	<canvas width='500' height='500' id='canvas'></canvas>
	<div id='tag-container'>
		<input type='text' id='tag' />
	</div>
	<script>
		window.onload = function() {
			let files = document.getElementById('file');
			let reader = new FileReader();
			let canvas = document.getElementById('canvas');
			let photoTag = new PhotoTag(canvas);
			let canvasBox = canvas.getBoundingClientRect();
			let tag = document.getElementById('tag');
			let btnDetector = document.getElementById('detector');
			let face = null;

			reader.onload = () => {
				let image = new Image();
				image.src = reader.result;
				image.onload = function() {
					photoTag && photoTag.drawZoomImage({
						img: image,
						w: image.width,
						h: image.height
					});
				}
			}

			files.addEventListener('change', () => {
				console.log(files.files);
				if(files.files.length === 0) {
					return;
				}

				reader.readAsDataURL(files.files[0]);
			})

			canvas.addEventListener('mousedown', e => {
				// 计算鼠标在canvas中的位置
				let eX = e.x - canvasBox.left;
				let eY = e.y - canvasBox.top;

				face = photoTag && photoTag.findFace(eX, eY) || null;
				tag.value = '';
			});

			tag.addEventListener('blur', () => {
				if(!tag.value || !photoTag || !face) {
					return;
				}
				photoTag.drawZoomImage();
				photoTag.faces.forEach(face => {
					photoTag.drawRect(face.boundingBox);
				})

				console.log(face.boundingBox.x)
				console.log(face.boundingBox.y)
				photoTag.drawText(tag.value, face.boundingBox.x, face.boundingBox.y - 50);
			})

			btnDetector.addEventListener('click', () => {
				photoTag && photoTag.faceDetector();
			})
		}

		class PhotoTag {
			constructor(canvas, detectorOpt) {
				this.initCtx(canvas)
					.catch(err => {
						throw(new Error(err))
					})
				this.aspect = 1;
				this.detector = new FaceDetector(detectorOpt);
			}

			initCtx(canvas) {
					if(!canvas) {
						this.canvas = document.createElement('canvas');
						document.body.appendChild(this.canvas);
					}else {
						this.canvas = canvas;
					}
				return new Promise((resolve, reject) => {

					this.ctx = this.canvas.getContext('2d');
					if(!this.ctx) {
						reject("you broswer does't support canvas");
					}
				})
			}

			drawOriginImage(img, s=0, e=0) {
				img = img || this.image;
				if(!img) {
					return;
				}
				this.ctx.drawImage(img, s, e);
				this.image = img;
				return this;
			}

			drawZoomImage(image={
				img: this.image,
				w: 0,
				h: 0
			}) {
				let scale = 1;
				let canvas = this.canvas;
				this.clearRect(0, 0, canvas.w, canvas.h);

				if(image.w / canvas.width >= image.h / canvas.height) {
					scale = image.h / image.w;
					let scaleH = canvas.width * scale;
					this.aspect = scaleH / image.height;
					this.ctx.drawImage(image.img, 0, 0, image.w, image.h, 0, 0, canvas.width, scaleH);
				}else {
					scale = image.w / image.h;
					let scaleW = canvas.height * scale;
					this.aspect = scaleW / image.w;
					this.ctx.drawImage(image.img, 0, 0, image.w, image.h, 0, 0, scaleW, canvas.height);
				}
				// 保存缩放后的照片
				this.image = new Image();
				this.image.src = this.canvas.toDataURL();
			}

			faceDetector(img=this.image, aspect = 1) {
				if(!img) {
					return;
				}
				this.detector.detect(img)
					.then(faces => {
						if(faces.length === 0) {
							alert('检测不到面部哦');
							return;
						}
						this.faces = faces;
						this.ctx.lineWidth = 2;
						this.ctx.strokeStyle = 'red';
						faces.forEach(face => {
							this.drawRect(face.boundingBox);
						})
					})
					.catch(err => {
						console.log(err)
					})
			}

			clearRect(x, y, w, h) {
				this.ctx.clearRect(x, y, w, h);
			}

			/*
			 * 查找(x,y)是否在某个面部区域内
			 */
			findFace(x, y) {
				if(!this.faces || this.faces.length <= 0 || x < 0 || y < 0) {
					return null;
				}

				if(!this.image && (x > this.image.width || y > this.image.height)) {
					return null;
				}

				let indexFace = null;
				this.faces.forEach(face => {
					let box = face.boundingBox;
					if(x >= box.left && x <= box.right && y >= box.top && y <= box.bottom) {
						indexFace =  face;
					}
				})

				return indexFace;
			}

			drawText(text, x, y, color='white') {
				this.ctx.save();
				this.ctx.fillStyle = color;
				this.ctx.font = '48px serif';
				this.ctx.textBaseline = 'top';
				this.ctx.fillText(text, x, y)
				this.ctx.restore();
			}

			drawRect(rect={}, aspect = 1) {
				this.ctx.rect(Math.floor(rect.x * aspect),
								Math.floor(rect.y * aspect),
								Math.floor(rect.width * aspect),
								Math.floor(rect.height * aspect)
							);
				this.ctx.stroke();
			}
		}

		class Detector {
			constructor(detectorOpt = {
				fastMode: true,
				maxDetectedFaces: 10
			}) {
				this.detector = new FaceDetector(detectorOpt);
			}


			faceDetector(image, aspect = 1) {
				if(!image) {
					return;
				}
				let self = this;
				this.detector.detect(image)
					.then(faces => {
						console.log(self)
						self.faces = faces;
						self.ctx.lineWidth = 2;
						self.ctx.strokeStyle = 'red';
						faces.forEach(face => {
							self.drawRect(face.boundingBox);
						})
					})
					.catch(err => {
						console.log(err)
					})
			}

			getIndex(x, y) {
				return -1;
			}
		}
	</script>
</body>
</html>